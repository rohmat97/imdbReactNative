'use strict';

var is = require('@redux-saga/is');
var ramda = require('ramda');
var reduxSaga_effects = require('redux-saga/effects');
var ramdasauce = require('ramdasauce');

// effect names
var TAKE = reduxSaga_effects.effectTypes.TAKE;
var PUT = reduxSaga_effects.effectTypes.PUT;
var ALL = reduxSaga_effects.effectTypes.ALL;
var RACE = reduxSaga_effects.effectTypes.RACE;
var CALL = reduxSaga_effects.effectTypes.CALL;
var CPS = reduxSaga_effects.effectTypes.CPS;
var FORK = reduxSaga_effects.effectTypes.FORK;
var JOIN = reduxSaga_effects.effectTypes.JOIN;
var CANCEL = reduxSaga_effects.effectTypes.CANCEL;
var SELECT = reduxSaga_effects.effectTypes.SELECT;
var ACTION_CHANNEL = reduxSaga_effects.effectTypes.ACTION_CHANNEL;
var CANCELLED = reduxSaga_effects.effectTypes.CANCELLED;
var FLUSH = reduxSaga_effects.effectTypes.FLUSH;
var GET_CONTEXT = reduxSaga_effects.effectTypes.GET_CONTEXT;
var SET_CONTEXT = reduxSaga_effects.effectTypes.SET_CONTEXT;
var PARALLEL = "PARALLEL";
var ITERATOR = "ITERATOR";
var PROMISE = "PROMISE"; // not from redux-saga
var UNKNOWN = "UNKNOWN"; // not from redux-saga

// monitoring statuses
var PENDING = "PENDING";
var RESOLVED = "RESOLVED";
var REJECTED = "REJECTED";

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/** The manager is used for bookkeeping all the effect descriptors */
var Manager = function () {
  function Manager() {
    classCallCheck(this, Manager);

    this.rootIds = [];
    // effect-id-to-effect-descriptor
    this.map = {};
    // effect-id-to-array-of-child-id
    this.childIdsMap = {};
  }

  createClass(Manager, [{
    key: "get",
    value: function get$$1(effectId) {
      return this.map[effectId];
    }
  }, {
    key: "set",
    value: function set$$1(effectId, desc) {
      this.map[effectId] = desc;

      if (this.childIdsMap[desc.parentEffectId] == null) {
        this.childIdsMap[desc.parentEffectId] = [];
      }
      this.childIdsMap[desc.parentEffectId].push(effectId);
    }
  }, {
    key: "setRootEffect",
    value: function setRootEffect(effectId, desc) {
      this.rootIds.push(effectId);
      this.set(effectId, Object.assign({ root: true }, desc));
    }
  }, {
    key: "getRootIds",
    value: function getRootIds() {
      return this.rootIds;
    }
  }, {
    key: "getChildIds",
    value: function getChildIds(parentEffectId) {
      return this.childIdsMap[parentEffectId] || [];
    }
  }]);
  return Manager;
}();

// Provides an additional description of the effect.  A friendlier name
// to display to the humans.
/* eslint-disable no-cond-assign */
var getDescri = (function (effect$$1) {
  if (!effect$$1) return UNKNOWN;
  if (effect$$1.root) return effect$$1.saga.name;
  if (is.iterator(effect$$1)) return effect$$1.name;
  if (is.promise(effect$$1)) {
    var display = void 0;
    if (effect$$1.name) {
      // a promise object with a manually set name prop for display reasons
      display = PROMISE + '(' + effect$$1.name + ')';
    } else if (effect$$1.constructor instanceof Promise.constructor) {
      // an anonymous promise
      display = PROMISE;
    } else {
      // class which extends Promise, so output the name of the class to precise
      display = PROMISE + '(' + effect$$1.constructor.name + ')';
    }
    return display;
  }
  if (is.effect(effect$$1)) {
    var type = effect$$1.type,
        data = effect$$1.payload;

    if (type === TAKE) {
      return data.pattern || 'channel';
    } else if (type === PUT) {
      return data.channel ? data.action : data.action.type;
    } else if (type === ALL) {
      return data;
    } else if (type === RACE) {
      return null;
    } else if (type === CALL) {
      return ramdasauce.isNilOrEmpty(data.fn.name) ? '(anonymous)' : data.fn.name;
    } else if (type === CPS) {
      return data.fn.name;
    } else if (type === FORK) {
      return data.fn.name;
    } else if (type === JOIN) {
      return data.name;
    } else if (type === CANCEL) {
      return data.name;
    } else if (type === SELECT) {
      return data.selector.name;
    } else if (type === ACTION_CHANNEL) {
      return data.buffer == null ? data.pattern : data;
    } else if (type === CANCELLED) {
      return null;
    } else if (type === FLUSH) {
      return data;
    } else if (type === GET_CONTEXT) {
      return data;
    } else if (type === SET_CONTEXT) {
      return data;
    }
  }
  if (is.array(effect$$1)) return null;

  return UNKNOWN;
});

var getName = (function (effect$$1) {
  if (!effect$$1) return UNKNOWN;
  if (is.promise(effect$$1)) return PROMISE;
  if (is.effect(effect$$1)) {
    var type = effect$$1.type;

    if (type === TAKE) {
      return TAKE;
    } else if (type === PUT) {
      return PUT;
    } else if (type === ALL) {
      return ALL;
    } else if (type === RACE) {
      return RACE;
    } else if (type === CALL) {
      return CALL;
    } else if (type === CPS) {
      return CPS;
    } else if (type === FORK) {
      return FORK;
    } else if (type === JOIN) {
      return JOIN;
    } else if (type === CANCEL) {
      return CANCEL;
    } else if (type === SELECT) {
      return SELECT;
    } else if (type === ACTION_CHANNEL) {
      return ACTION_CHANNEL;
    } else if (type === CANCELLED) {
      return CANCELLED;
    } else if (type === FLUSH) {
      return FLUSH;
    } else if (type === GET_CONTEXT) {
      return GET_CONTEXT;
    } else if (type === SET_CONTEXT) {
      return SET_CONTEXT;
    }
  }
  if (is.array(effect$$1)) return PARALLEL;
  if (is.iterator(effect$$1)) return ITERATOR;
  return UNKNOWN;
});

var isRaceEffect = function isRaceEffect(eff) {
  return is.effect(eff) && eff.type === reduxSaga_effects.effectTypes.RACE;
};
// import { reject, values, pluck, isNil, split, pathOr, last, forEach, propEq, filter, __, map, omit } from 'ramda'

// creates a saga monitor
var _createSagaMonitor = (function (reactotron, options) {
  var pluginConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  // a lookup table of effects - keys are numbers, values are objects
  var Manager$$1 = new Manager();
  var exceptions = pluginConfig.except || [];
  // start a relative timer
  var timer = reactotron.startTimer();
  // ---------------- Sending Effect Updates ----------------
  //const sendReactotronEffectTree = () => reactotron.send('saga.effect.update', effects)

  // ---------------- Starting -----------------------------

  var rootSagaStarted = function rootSagaStarted(description) {
    Manager$$1.setRootEffect(description.effectId, Object.assign({}, description, {
      status: PENDING,
      start: timer()
    }));
  };

  // redux-saga calls this when an effect is triggered (started)
  var effectTriggered = function effectTriggered(description) {
    Manager$$1.set(description.effectId, Object.assign({}, description, {
      status: PENDING,
      start: timer(),
      name: getName(description.effect),
      description: getDescri(description.effect)
    }));
  };

  // ---------------- Finishing ----------------------------

  // update the duration of the effect
  var updateDuration = function updateDuration(effectInfo) {
    effectInfo.duration = timer() - effectInfo.start;
  };

  // fires when a task has been resolved
  var taskResolved = function taskResolved(effectId, taskResult) {
    // lookup this effect info
    var effectInfo = Manager$$1.get(effectId);
    updateDuration(effectInfo);
    var duration = effectInfo.duration;

    // grab the parent too

    var parentEffectId = effectInfo.parentEffectId;

    var parentEffectInfo = Manager$$1.get(parentEffectId);
    var children = [];

    // a human friendly name of the saga task
    var sagaDescription = void 0;
    // what caused the trigger
    var triggerType = void 0;
    // for FORK tasks, we have a bunch on things to pass along
    if (effectInfo.name && effectInfo.name === FORK) {
      var args = effectInfo.effect.payload.args;
      var lastArg = ramda.last(args);
      triggerType = lastArg && lastArg.type;
      if (parentEffectInfo) {
        if (parentEffectInfo.name && parentEffectInfo.name === ITERATOR) {

          sagaDescription = parentEffectInfo.description;
        }
      } else {
        sagaDescription = "(root)";

        triggerType = effectInfo.description + "()";
      }

      // flatten out the nested effects
      var buildChild = function buildChild(depth, effectId) {
        var sourceEffectInfo = Manager$$1.get(effectId);
        if (ramda.isNil(sourceEffectInfo)) return;
        var extra = null;
        if (sourceEffectInfo.name) {

          switch (sourceEffectInfo.name) {
            case CALL:
              extra = sourceEffectInfo.effect.payload.args;
              break;

            case PUT:
              extra = sourceEffectInfo.effect.payload.action;
              break;

            // children handle this
            case RACE:
              break;

            // TODO: More of customizations needed here

            default:
              extra = sourceEffectInfo.effect.payload;
              break;
          }
        }

        // assemble the structure
        children.push({
          depth: depth,
          effectId: sourceEffectInfo.effectId,
          parentEffectId: sourceEffectInfo.parentEffectId || null,
          name: sourceEffectInfo.name || null,
          description: sourceEffectInfo.description || null,
          duration: Math.round(sourceEffectInfo.duration),
          status: sourceEffectInfo.status || null,
          winner: sourceEffectInfo.winner || null,
          loser: sourceEffectInfo.loser || null,
          result: sourceEffectInfo.result || null,
          extra: extra || null
        });

        // rerun this function for our children
        ramda.forEach(function (x) {
          return buildChild(depth + 1, x);
        }, Manager$$1.getChildIds(effectId));
      };
      var xs = Manager$$1.getChildIds(effectId);
      ramda.forEach(function (effectId) {
        return buildChild(0, effectId);
      }, xs);
    }
    // saga not blacklisted?
    if (!ramda.contains(effectInfo.description, exceptions)) {
      reactotron.send("saga.task.complete", {
        triggerType: triggerType || effectInfo.description,
        description: sagaDescription,
        duration: Math.round(duration),
        children: children
      });
    }
  };

  // redux-saga calls this when an effect is resolved (successfully or not)
  var effectResolved = function effectResolved(effectId, result) {
    resolveEffect(effectId, result);
  };

  // flags on of the children as the winner
  var setRaceWinner = function setRaceWinner(effectId, resultOrError) {
    var winnerLabel = Object.keys(resultOrError)[0];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = Manager$$1.getChildIds(effectId)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var childId = _step.value;

        var childEffect = Manager$$1.get(childId);
        if (childEffect.label === winnerLabel) {
          childEffect.winner = true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  };

  // ---------------- Failing ------------------------------

  // redux-saga calls this when an effect is rejected (an error has happened)
  var effectRejected = function effectRejected(effectId, error) {
    rejectEffect(effectId, error);
  };

  // ---------------- Cancelling ---------------------------

  // redux-saga calls this when an effect is cancelled
  var effectCancelled = function effectCancelled(effectId) {
    cancelEffect(effectId);
  };

  var computeEffectDur = function computeEffectDur(effect$$1) {
    var now = timer();
    Object.assign(effect$$1, {
      end: now,
      duration: now - effect$$1.start
    });
  };

  var resolveEffect = function resolveEffect(effectId, result) {
    var effect$$1 = Manager$$1.get(effectId);
    if (is.task(result)) {
      result.toPromise().then(function (taskResult) {
        if (result.isCancelled()) {
          cancelEffect(effectId);
        } else {
          resolveEffect(effectId, taskResult);
          taskResolved(effectId, taskResult);
        }
      }, function (taskError) {
        return rejectEffect(effectId, taskError);
      });
    } else {
      computeEffectDur(effect$$1);
      effect$$1.status = RESOLVED;
      effect$$1.result = result;
      updateDuration(effect$$1);
      if (isRaceEffect(effect$$1.effect)) {
        setRaceWinner(effectId, result);
      }
    }
  };

  var rejectEffect = function rejectEffect(effectId, error) {
    var effect$$1 = Manager$$1.get(effectId);
    computeEffectDur(effect$$1);
    effect$$1.status = REJECTED;
    effect$$1.error = error;
    updateDuration(effect$$1);
    if (isRaceEffect(effect$$1.effect)) {
      setRaceWinner(effectId, error);
    }
  };

  var cancelEffect = function cancelEffect(effectId) {
    var effect$$1 = Manager$$1.get(effectId);
    computeEffectDur(effect$$1);
    effect$$1.status = CANCELLED;
    updateDuration(effect$$1);
  };

  // the interface for becoming a redux-saga monitor
  return {
    rootSagaStarted: rootSagaStarted,
    effectTriggered: effectTriggered,
    effectResolved: effectResolved,
    effectRejected: effectRejected,
    effectCancelled: effectCancelled,
    actionDispatched: function actionDispatched() {}
  };
});

// Behold!  The entry point of our plugin
var plugin$1 = (function (pluginConfig) {
  return function (reactotron) {
    return {
      // make these functions available on the Reactotron
      features: {
        // spawn a saga monitor with the given options
        createSagaMonitor: function createSagaMonitor(options) {
          return _createSagaMonitor(reactotron, options, pluginConfig);
        }
      }
    };
  };
});

module.exports = plugin$1;
